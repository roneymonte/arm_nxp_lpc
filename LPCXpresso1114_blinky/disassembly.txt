
LPCXpresso1114_blinky.axf:     file format elf32-littlearm


Disassembly of section .text:

00000000 <g_pfnVectors>:
** 						
** Returned value:		None
** 
*****************************************************************************/
void WDT_CLK_Setup ( uint32_t clksrc )
{
   0:	f0 1f 00 10 6d 01 00 00 e1 01 00 00 e9 01 00 00     ....m...........
	...
  /* debug PLL after configuration. */
  LPC_SYSCON->CLKOUTCLKSEL = clksrc;	/* Select Main clock */
  LPC_SYSCON->CLKOUTUEN = 0x01;		/* Update clock */
  LPC_SYSCON->CLKOUTUEN = 0x00;		/* Toggle update register once */
  LPC_SYSCON->CLKOUTUEN = 0x01;
  while ( !(LPC_SYSCON->CLKOUTUEN & 0x01) );		/* Wait until updated */
  2c:	f1 01 00 00 00 00 00 00 00 00 00 00 f9 01 00 00     ................
  LPC_SYSCON->CLKOUTDIV = 1;			/* Divided by 1 */
  3c:	01 02 00 00 09 02 00 00 09 02 00 00 09 02 00 00     ................
  {
	case PORT0:
	  LPC_GPIO0->IE &= ~(0x1<<bitPosi); 
	break;
 	case PORT1:
	  LPC_GPIO1->IE &= ~(0x1<<bitPosi);	
  4c:	09 02 00 00 09 02 00 00 09 02 00 00 09 02 00 00     ................
	break;
 	case PORT1:
	  LPC_GPIO1->IE |= (0x1<<bitPosi);	
	break;
	case PORT2:
	  LPC_GPIO2->IE |= (0x1<<bitPosi);	    
  5c:	09 02 00 00 09 02 00 00 09 02 00 00 09 02 00 00     ................
	break;
 	case PORT1:
	  LPC_GPIO1->IE &= ~(0x1<<bitPosi);	
	break;
	case PORT2:
	  LPC_GPIO2->IE &= ~(0x1<<bitPosi);	    
  6c:	09 02 00 00 09 02 00 00 09 02 00 00 09 02 00 00     ................
	break;
	case PORT3:
	  LPC_GPIO3->IE &= ~(0x1<<bitPosi);	    
  7c:	09 02 00 00 a1 06 00 00 c1 06 00 00 09 02 00 00     ................
		regVal = 1;		    
	break;
	default:
	  break;
  }
  return ( regVal );
  8c:	09 02 00 00 09 02 00 00 09 02 00 00 09 02 00 00     ................
		  LPC_GPIO0->IBE &= ~(0x1<<bitPosi);
		else
		  LPC_GPIO0->IBE |= (0x1<<bitPosi);
	  }
	  else
	  	LPC_GPIO0->IS |= (0x1<<bitPosi);
  9c:	09 02 00 00 09 02 00 00 09 02 00 00 09 02 00 00     ................
	  if ( event == 0 )
  ac:	09 02 00 00 09 02 00 00 09 02 00 00 09 02 00 00     ................
		LPC_GPIO0->IEV &= ~(0x1<<bitPosi);
  bc:	09 02 00 00                                         ....

000000c0 <main>:
  c0:	b580      	push	{r7, lr}
  c2:	af00      	add	r7, sp, #0
  c4:	f000 f8a4 	bl	210 <GPIOInit>
  c8:	4b25      	ldr	r3, [pc, #148]	(160 <main+0xa0>)
  ca:	681a      	ldr	r2, [r3, #0]
  cc:	4b25      	ldr	r3, [pc, #148]	(164 <main+0xa4>)
  ce:	6f9b      	ldr	r3, [r3, #120]
	  else
		LPC_GPIO0->IEV |= (0x1<<bitPosi);
  d0:	1c10      	adds	r0, r2, #0
  d2:	1c19      	adds	r1, r3, #0
  d4:	f000 fb7c 	bl	7d0 <__aeabi_uidiv>
  d8:	1c03      	adds	r3, r0, #0
  da:	1c1a      	adds	r2, r3, #0
  dc:	23fa      	movs	r3, #250
  de:	00db      	lsls	r3, r3, #3
  e0:	1c10      	adds	r0, r2, #0
  e2:	1c19      	adds	r1, r3, #0
  e4:	f000 fb74 	bl	7d0 <__aeabi_uidiv>
  e8:	1c03      	adds	r3, r0, #0
  ea:	2000      	movs	r0, #0
	break;
 	case PORT1:
	  if ( sense == 0 )
  ec:	1c19      	adds	r1, r3, #0
  ee:	f000 fa31 	bl	554 <init_timer16>
	  {
		LPC_GPIO1->IS &= ~(0x1<<bitPosi);
  f2:	4a1d      	ldr	r2, [pc, #116]	(168 <main+0xa8>)
  f4:	2300      	movs	r3, #0
  f6:	6013      	str	r3, [r2, #0]
  f8:	2000      	movs	r0, #0
  fa:	f000 fa13 	bl	524 <enable_timer16>
  fe:	2000      	movs	r0, #0
 100:	2107      	movs	r1, #7
 102:	2201      	movs	r2, #1
 104:	f000 f8b2 	bl	26c <GPIOSetDir>
 108:	4b17      	ldr	r3, [pc, #92]	(168 <main+0xa8>)
		/* single or double only applies when sense is 0(edge trigger). */
		if ( single == 0 )
 10a:	681b      	ldr	r3, [r3, #0]
 10c:	2b00      	cmp	r3, #0
 10e:	d00a      	beq.n	126 <main+0x66>
		  LPC_GPIO1->IBE &= ~(0x1<<bitPosi);
 110:	4b15      	ldr	r3, [pc, #84]	(168 <main+0xa8>)
 112:	681a      	ldr	r2, [r3, #0]
 114:	23fa      	movs	r3, #250
 116:	009b      	lsls	r3, r3, #2
 118:	429a      	cmp	r2, r3
 11a:	d804      	bhi.n	126 <main+0x66>
 11c:	2000      	movs	r0, #0
 11e:	2107      	movs	r1, #7
 120:	2200      	movs	r2, #0
 122:	f000 f9a9 	bl	478 <GPIOSetValue>
 126:	4b10      	ldr	r3, [pc, #64]	(168 <main+0xa8>)
 128:	681a      	ldr	r2, [r3, #0]
		else
		  LPC_GPIO1->IBE |= (0x1<<bitPosi);
 12a:	23fa      	movs	r3, #250
 12c:	009b      	lsls	r3, r3, #2
 12e:	429a      	cmp	r2, r3
 130:	d90b      	bls.n	14a <main+0x8a>
 132:	4b0d      	ldr	r3, [pc, #52]	(168 <main+0xa8>)
 134:	681a      	ldr	r2, [r3, #0]
 136:	23fa      	movs	r3, #250
 138:	00db      	lsls	r3, r3, #3
 13a:	429a      	cmp	r2, r3
 13c:	d805      	bhi.n	14a <main+0x8a>
 13e:	2000      	movs	r0, #0
 140:	2107      	movs	r1, #7
	  }
	  else
	  	LPC_GPIO1->IS |= (0x1<<bitPosi);
 142:	2201      	movs	r2, #1
 144:	f000 f998 	bl	478 <GPIOSetValue>
 148:	e7de      	b.n	108 <main+0x48>
 14a:	4b07      	ldr	r3, [pc, #28]	(168 <main+0xa8>)
 14c:	681a      	ldr	r2, [r3, #0]
 14e:	23fa      	movs	r3, #250
 150:	00db      	lsls	r3, r3, #3
 152:	429a      	cmp	r2, r3
 154:	d9d8      	bls.n	108 <main+0x48>
 156:	4a04      	ldr	r2, [pc, #16]	(168 <main+0xa8>)
	  if ( event == 0 )
 158:	2300      	movs	r3, #0
 15a:	6013      	str	r3, [r2, #0]
 15c:	e7d4      	b.n	108 <main+0x48>
		LPC_GPIO1->IEV &= ~(0x1<<bitPosi);
 15e:	46c0      	nop			(mov r8, r8)
 160:	10000000 	.word	0x10000000
 164:	40048000 	.word	0x40048000
 168:	10000004 	.word	0x10000004

0000016c <Reset_Handler>:
 16c:	b580      	push	{r7, lr}
 16e:	b082      	sub	sp, #8
 170:	af00      	add	r7, sp, #0
 172:	4b15      	ldr	r3, [pc, #84]	(1c8 <Reset_Handler+0x5c>)
 174:	603b      	str	r3, [r7, #0]
 176:	4b15      	ldr	r3, [pc, #84]	(1cc <Reset_Handler+0x60>)
	  else
		LPC_GPIO1->IEV |= (0x1<<bitPosi);  
 178:	607b      	str	r3, [r7, #4]
 17a:	e009      	b.n	190 <Reset_Handler+0x24>
 17c:	683b      	ldr	r3, [r7, #0]
 17e:	781b      	ldrb	r3, [r3, #0]
 180:	687a      	ldr	r2, [r7, #4]
 182:	7013      	strb	r3, [r2, #0]
 184:	687b      	ldr	r3, [r7, #4]
 186:	3301      	adds	r3, #1
 188:	607b      	str	r3, [r7, #4]
 18a:	683b      	ldr	r3, [r7, #0]
 18c:	3301      	adds	r3, #1
 18e:	603b      	str	r3, [r7, #0]
	break;
	case PORT2:
	  if ( sense == 0 )
 190:	687a      	ldr	r2, [r7, #4]
 192:	4b0f      	ldr	r3, [pc, #60]	(1d0 <Reset_Handler+0x64>)
 194:	429a      	cmp	r2, r3
	  {
		LPC_GPIO2->IS &= ~(0x1<<bitPosi);
 196:	d3f1      	bcc.n	17c <Reset_Handler+0x10>
 198:	4b0e      	ldr	r3, [pc, #56]	(1d4 <Reset_Handler+0x68>)
 19a:	607b      	str	r3, [r7, #4]
 19c:	e005      	b.n	1aa <Reset_Handler+0x3e>
 19e:	687a      	ldr	r2, [r7, #4]
 1a0:	2300      	movs	r3, #0
 1a2:	7013      	strb	r3, [r2, #0]
 1a4:	687b      	ldr	r3, [r7, #4]
 1a6:	3301      	adds	r3, #1
 1a8:	607b      	str	r3, [r7, #4]
 1aa:	687a      	ldr	r2, [r7, #4]
 1ac:	4b0a      	ldr	r3, [pc, #40]	(1d8 <Reset_Handler+0x6c>)
		/* single or double only applies when sense is 0(edge trigger). */
		if ( single == 0 )
 1ae:	429a      	cmp	r2, r3
 1b0:	d3f5      	bcc.n	19e <Reset_Handler+0x32>
 1b2:	f000 fa95 	bl	6e0 <SystemInit>
		  LPC_GPIO2->IBE &= ~(0x1<<bitPosi);
 1b6:	4b09      	ldr	r3, [pc, #36]	(1dc <Reset_Handler+0x70>)
 1b8:	2b00      	cmp	r3, #0
 1ba:	d002      	beq.n	1c2 <Reset_Handler+0x56>
 1bc:	e000      	b.n	1c0 <Reset_Handler+0x54>
 1be:	bf00      	nop
 1c0:	e001      	b.n	1c6 <Reset_Handler+0x5a>
 1c2:	f7ff ff7d 	bl	c0 <main>
 1c6:	e7fe      	b.n	1c6 <Reset_Handler+0x5a>
 1c8:	00000844 	.word	0x00000844
 1cc:	10000000 	.word	0x10000000
		else
		  LPC_GPIO2->IBE |= (0x1<<bitPosi);
 1d0:	0004      	.short	0x0004
 1d2:	1000      	.short	0x1000
 1d4:	10000004 	.word	0x10000004
 1d8:	1000000c 	.word	0x1000000c
 1dc:	00000000 	.word	0x00000000

000001e0 <NMI_Handler>:
 1e0:	b580      	push	{r7, lr}
 1e2:	af00      	add	r7, sp, #0
 1e4:	e7fe      	b.n	1e4 <NMI_Handler+0x4>
	  }
	  else
	  	LPC_GPIO2->IS |= (0x1<<bitPosi);
 1e6:	46c0      	nop			(mov r8, r8)

000001e8 <HardFault_Handler>:
 1e8:	b580      	push	{r7, lr}
 1ea:	af00      	add	r7, sp, #0
 1ec:	e7fe      	b.n	1ec <HardFault_Handler+0x4>
 1ee:	46c0      	nop			(mov r8, r8)

000001f0 <SVCall_Handler>:
 1f0:	b580      	push	{r7, lr}
 1f2:	af00      	add	r7, sp, #0
 1f4:	e7fe      	b.n	1f4 <SVCall_Handler+0x4>
 1f6:	46c0      	nop			(mov r8, r8)

000001f8 <PendSV_Handler>:
 1f8:	b580      	push	{r7, lr}
 1fa:	af00      	add	r7, sp, #0
	  if ( event == 0 )
 1fc:	e7fe      	b.n	1fc <PendSV_Handler+0x4>
 1fe:	46c0      	nop			(mov r8, r8)

00000200 <SysTick_Handler>:
 200:	b580      	push	{r7, lr}
		LPC_GPIO2->IEV &= ~(0x1<<bitPosi);
 202:	af00      	add	r7, sp, #0
 204:	e7fe      	b.n	204 <SysTick_Handler+0x4>
 206:	46c0      	nop			(mov r8, r8)

00000208 <IntDefaultHandler>:
 208:	b580      	push	{r7, lr}
 20a:	af00      	add	r7, sp, #0
 20c:	e7fe      	b.n	20c <IntDefaultHandler+0x4>
 20e:	46c0      	nop			(mov r8, r8)

00000210 <GPIOInit>:
**						is full and GPIO interrupt handler can be
**						installed.
** 
*****************************************************************************/
void GPIOInit( void )
{
 210:	b580      	push	{r7, lr}
 212:	af00      	add	r7, sp, #0
  /* Enable AHB clock to the GPIO domain. */
  LPC_SYSCON->SYSAHBCLKCTRL |= (1<<6);
 214:	490a      	ldr	r1, [pc, #40]	(240 <GPIOInit+0x30>)
 216:	4a0a      	ldr	r2, [pc, #40]	(240 <GPIOInit+0x30>)
 218:	2380      	movs	r3, #128
 21a:	58d2      	ldr	r2, [r2, r3]
	  else
	  	LPC_GPIO2->IS |= (0x1<<bitPosi);
	  if ( event == 0 )
		LPC_GPIO2->IEV &= ~(0x1<<bitPosi);
	  else
		LPC_GPIO2->IEV |= (0x1<<bitPosi);  
 21c:	2340      	movs	r3, #64
 21e:	431a      	orrs	r2, r3
 220:	2380      	movs	r3, #128
 222:	50ca      	str	r2, [r1, r3]
  LPC_IOCON->JTAG_TDO_PIO1_1  &= ~0x07;
  LPC_IOCON->JTAG_TDO_PIO1_1  |= 0x01;
#endif

  /* Set up NVIC when I/O pins are configured as external interrupts. */
  NVIC_EnableIRQ(EINT0_IRQn);
 224:	201f      	movs	r0, #31
 226:	f000 f80d 	bl	244 <NVIC_EnableIRQ>
  NVIC_EnableIRQ(EINT1_IRQn);
 22a:	201e      	movs	r0, #30
 22c:	f000 f80a 	bl	244 <NVIC_EnableIRQ>
  NVIC_EnableIRQ(EINT2_IRQn);
 230:	201d      	movs	r0, #29
 232:	f000 f807 	bl	244 <NVIC_EnableIRQ>
  NVIC_EnableIRQ(EINT3_IRQn);
 236:	201c      	movs	r0, #28
 238:	f000 f804 	bl	244 <NVIC_EnableIRQ>
  return;
}
 23c:	46bd      	mov	sp, r7
 23e:	bd80      	pop	{r7, pc}
 240:	40048000 	.word	0x40048000

00000244 <NVIC_EnableIRQ>:
 *
 * Enable a device specific interupt in the NVIC interrupt controller.
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
 244:	b580      	push	{r7, lr}
 246:	b082      	sub	sp, #8
 248:	af00      	add	r7, sp, #0
 24a:	1c03      	adds	r3, r0, #0
 24c:	1dfa      	adds	r2, r7, #7
 24e:	7013      	strb	r3, [r2, #0]
  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
 250:	4905      	ldr	r1, [pc, #20]	(268 <NVIC_EnableIRQ+0x24>)
	case PORT3:
	  if ( sense == 0 )
	  {
		LPC_GPIO3->IS &= ~(0x1<<bitPosi);
		/* single or double only applies when sense is 0(edge trigger). */
		if ( single == 0 )
 252:	1dfb      	adds	r3, r7, #7
 254:	781b      	ldrb	r3, [r3, #0]
 256:	1c1a      	adds	r2, r3, #0
		  LPC_GPIO3->IBE &= ~(0x1<<bitPosi);
 258:	231f      	movs	r3, #31
 25a:	401a      	ands	r2, r3
 25c:	2301      	movs	r3, #1
 25e:	4093      	lsls	r3, r2
 260:	600b      	str	r3, [r1, #0]
}
 262:	46bd      	mov	sp, r7
 264:	b002      	add	sp, #8
 266:	bd80      	pop	{r7, pc}
 268:	e000e100 	.word	0xe000e100

0000026c <GPIOSetDir>:
** parameters:			port num, bit position, direction (1 out, 0 input)
** Returned value:		None
** 
*****************************************************************************/
void GPIOSetDir( uint32_t portNum, uint32_t bitPosi, uint32_t dir )
{
 26c:	b580      	push	{r7, lr}
 26e:	b084      	sub	sp, #16
 270:	af00      	add	r7, sp, #0
		LPC_GPIO3->IS &= ~(0x1<<bitPosi);
		/* single or double only applies when sense is 0(edge trigger). */
		if ( single == 0 )
		  LPC_GPIO3->IBE &= ~(0x1<<bitPosi);
		else
		  LPC_GPIO3->IBE |= (0x1<<bitPosi);
 272:	60f8      	str	r0, [r7, #12]
 274:	60b9      	str	r1, [r7, #8]
 276:	607a      	str	r2, [r7, #4]
  /* if DIR is OUT(1), but GPIOx_DIR is not set, set DIR
  to OUT(1); if DIR is IN(0), but GPIOx_DIR is set, clr
  DIR to IN(0). All the other cases are ignored. 
  On port3(bit 0 through 3 only), no error protection if 
  bit value is out of range. */
  switch ( portNum )
 278:	68fb      	ldr	r3, [r7, #12]
 27a:	603b      	str	r3, [r7, #0]
 27c:	683b      	ldr	r3, [r7, #0]
 27e:	2b01      	cmp	r3, #1
 280:	d04a      	beq.n	318 <GPIOSetDir+0xac>
 282:	683b      	ldr	r3, [r7, #0]
 284:	2b01      	cmp	r3, #1
 286:	d308      	bcc.n	29a <GPIOSetDir+0x2e>
 288:	683b      	ldr	r3, [r7, #0]
		  LPC_GPIO3->IBE &= ~(0x1<<bitPosi);
		else
		  LPC_GPIO3->IBE |= (0x1<<bitPosi);
	  }
	  else
	  	LPC_GPIO3->IS |= (0x1<<bitPosi);
 28a:	2b02      	cmp	r3, #2
 28c:	d100      	bne.n	290 <GPIOSetDir+0x24>
 28e:	e07c      	b.n	38a <GPIOSetDir+0x11e>
 290:	683b      	ldr	r3, [r7, #0]
 292:	2b03      	cmp	r3, #3
 294:	d100      	bne.n	298 <GPIOSetDir+0x2c>
 296:	e0af      	b.n	3f8 <GPIOSetDir+0x18c>
 298:	e0e4      	b.n	464 <GPIOSetDir+0x1f8>
  On port3(bit 0 through 3 only), no error protection if 
  bit value is out of range. */
  switch ( portNum )
  {
	case PORT0:
	  if ( !(LPC_GPIO0->DIR & (0x1<<bitPosi)) && (dir == 1) )
 29a:	22a0      	movs	r2, #160
 29c:	05d2      	lsls	r2, r2, #23
 29e:	2380      	movs	r3, #128
		else
		  LPC_GPIO3->IBE |= (0x1<<bitPosi);
	  }
	  else
	  	LPC_GPIO3->IS |= (0x1<<bitPosi);
	  if ( event == 0 )
 2a0:	021b      	lsls	r3, r3, #8
 2a2:	58d1      	ldr	r1, [r2, r3]
 2a4:	68ba      	ldr	r2, [r7, #8]
		LPC_GPIO3->IEV &= ~(0x1<<bitPosi);
 2a6:	2301      	movs	r3, #1
 2a8:	4093      	lsls	r3, r2
 2aa:	400b      	ands	r3, r1
 2ac:	2b00      	cmp	r3, #0
 2ae:	d112      	bne.n	2d6 <GPIOSetDir+0x6a>
 2b0:	687b      	ldr	r3, [r7, #4]
 2b2:	2b01      	cmp	r3, #1
 2b4:	d10f      	bne.n	2d6 <GPIOSetDir+0x6a>
  bit value is out of range. */
  switch ( portNum )
  {
	case PORT0:
	  if ( !(LPC_GPIO0->DIR & (0x1<<bitPosi)) && (dir == 1) )
		LPC_GPIO0->DIR |= (0x1<<bitPosi);
 2b6:	21a0      	movs	r1, #160
 2b8:	05c9      	lsls	r1, r1, #23
 2ba:	22a0      	movs	r2, #160
 2bc:	05d2      	lsls	r2, r2, #23
 2be:	2380      	movs	r3, #128
	  else
	  	LPC_GPIO3->IS |= (0x1<<bitPosi);
	  if ( event == 0 )
		LPC_GPIO3->IEV &= ~(0x1<<bitPosi);
	  else
		LPC_GPIO3->IEV |= (0x1<<bitPosi);	  
 2c0:	021b      	lsls	r3, r3, #8
 2c2:	58d0      	ldr	r0, [r2, r3]
 2c4:	68ba      	ldr	r2, [r7, #8]
 2c6:	2301      	movs	r3, #1
 2c8:	4093      	lsls	r3, r2
 2ca:	1c02      	adds	r2, r0, #0
 2cc:	431a      	orrs	r2, r3
 2ce:	2380      	movs	r3, #128
 2d0:	021b      	lsls	r3, r3, #8
 2d2:	50ca      	str	r2, [r1, r3]
 2d4:	e0c6      	b.n	464 <GPIOSetDir+0x1f8>
  switch ( portNum )
  {
	case PORT0:
	  if ( !(LPC_GPIO0->DIR & (0x1<<bitPosi)) && (dir == 1) )
		LPC_GPIO0->DIR |= (0x1<<bitPosi);
	  else if ( (LPC_GPIO0->DIR & (0x1<<bitPosi)) && (dir == 0) )
 2d6:	22a0      	movs	r2, #160
 2d8:	05d2      	lsls	r2, r2, #23
 2da:	2380      	movs	r3, #128
 2dc:	021b      	lsls	r3, r3, #8
 2de:	58d1      	ldr	r1, [r2, r3]
 2e0:	68ba      	ldr	r2, [r7, #8]
 2e2:	2301      	movs	r3, #1
 2e4:	4093      	lsls	r3, r2
 2e6:	400b      	ands	r3, r1
 2e8:	2b00      	cmp	r3, #0
 2ea:	d100      	bne.n	2ee <GPIOSetDir+0x82>
 2ec:	e0ba      	b.n	464 <GPIOSetDir+0x1f8>
 2ee:	687b      	ldr	r3, [r7, #4]
 2f0:	2b00      	cmp	r3, #0
 2f2:	d000      	beq.n	2f6 <GPIOSetDir+0x8a>
	break;
	default:
	  break;
  }
  return;
}
 2f4:	e0b6      	b.n	464 <GPIOSetDir+0x1f8>
  {
	case PORT0:
	  if ( !(LPC_GPIO0->DIR & (0x1<<bitPosi)) && (dir == 1) )
		LPC_GPIO0->DIR |= (0x1<<bitPosi);
	  else if ( (LPC_GPIO0->DIR & (0x1<<bitPosi)) && (dir == 0) )
		LPC_GPIO0->DIR &= ~(0x1<<bitPosi);	  
 2f6:	21a0      	movs	r1, #160
 2f8:	05c9      	lsls	r1, r1, #23
 2fa:	22a0      	movs	r2, #160
 2fc:	05d2      	lsls	r2, r2, #23
 2fe:	2380      	movs	r3, #128
 300:	021b      	lsls	r3, r3, #8
 302:	58d0      	ldr	r0, [r2, r3]
 304:	68ba      	ldr	r2, [r7, #8]
 306:	2301      	movs	r3, #1
 308:	4093      	lsls	r3, r2
 30a:	43db      	mvns	r3, r3
 30c:	1c02      	adds	r2, r0, #0
 30e:	401a      	ands	r2, r3
 310:	2380      	movs	r3, #128
 312:	021b      	lsls	r3, r3, #8
 314:	50ca      	str	r2, [r1, r3]
 316:	e0a5      	b.n	464 <GPIOSetDir+0x1f8>
	break;
 	case PORT1:
	  if ( !(LPC_GPIO1->DIR & (0x1<<bitPosi)) && (dir == 1) )
 318:	4a54      	ldr	r2, [pc, #336]	(46c <GPIOSetDir+0x200>)
 31a:	2380      	movs	r3, #128
 31c:	021b      	lsls	r3, r3, #8
 31e:	58d1      	ldr	r1, [r2, r3]
 320:	68ba      	ldr	r2, [r7, #8]
 322:	2301      	movs	r3, #1
 324:	4093      	lsls	r3, r2
 326:	400b      	ands	r3, r1
 328:	2b00      	cmp	r3, #0
 32a:	d110      	bne.n	34e <GPIOSetDir+0xe2>
 32c:	687b      	ldr	r3, [r7, #4]
 32e:	2b01      	cmp	r3, #1
 330:	d10d      	bne.n	34e <GPIOSetDir+0xe2>
		LPC_GPIO1->DIR |= (0x1<<bitPosi);
 332:	484e      	ldr	r0, [pc, #312]	(46c <GPIOSetDir+0x200>)
 334:	4a4d      	ldr	r2, [pc, #308]	(46c <GPIOSetDir+0x200>)
 336:	2380      	movs	r3, #128
 338:	021b      	lsls	r3, r3, #8
 33a:	58d1      	ldr	r1, [r2, r3]
 33c:	68ba      	ldr	r2, [r7, #8]
 33e:	2301      	movs	r3, #1
 340:	4093      	lsls	r3, r2
 342:	1c0a      	adds	r2, r1, #0
 344:	431a      	orrs	r2, r3
 346:	2380      	movs	r3, #128
 348:	021b      	lsls	r3, r3, #8
 34a:	50c2      	str	r2, [r0, r3]
 34c:	e08a      	b.n	464 <GPIOSetDir+0x1f8>
	  else if ( (LPC_GPIO1->DIR & (0x1<<bitPosi)) && (dir == 0) )
 34e:	4a47      	ldr	r2, [pc, #284]	(46c <GPIOSetDir+0x200>)
 350:	2380      	movs	r3, #128
 352:	021b      	lsls	r3, r3, #8
 354:	58d1      	ldr	r1, [r2, r3]
 356:	68ba      	ldr	r2, [r7, #8]
 358:	2301      	movs	r3, #1
 35a:	4093      	lsls	r3, r2
 35c:	400b      	ands	r3, r1
 35e:	2b00      	cmp	r3, #0
 360:	d100      	bne.n	364 <GPIOSetDir+0xf8>
 362:	e07f      	b.n	464 <GPIOSetDir+0x1f8>
 364:	687b      	ldr	r3, [r7, #4]
 366:	2b00      	cmp	r3, #0
 368:	d000      	beq.n	36c <GPIOSetDir+0x100>
 36a:	e07b      	b.n	464 <GPIOSetDir+0x1f8>
		LPC_GPIO1->DIR &= ~(0x1<<bitPosi);	  
 36c:	483f      	ldr	r0, [pc, #252]	(46c <GPIOSetDir+0x200>)
 36e:	4a3f      	ldr	r2, [pc, #252]	(46c <GPIOSetDir+0x200>)
 370:	2380      	movs	r3, #128
 372:	021b      	lsls	r3, r3, #8
 374:	58d1      	ldr	r1, [r2, r3]
 376:	68ba      	ldr	r2, [r7, #8]
 378:	2301      	movs	r3, #1
 37a:	4093      	lsls	r3, r2
 37c:	43db      	mvns	r3, r3
 37e:	1c0a      	adds	r2, r1, #0
 380:	401a      	ands	r2, r3
 382:	2380      	movs	r3, #128
 384:	021b      	lsls	r3, r3, #8
 386:	50c2      	str	r2, [r0, r3]
 388:	e06c      	b.n	464 <GPIOSetDir+0x1f8>
	break;
	case PORT2:
	  if ( !(LPC_GPIO2->DIR & (0x1<<bitPosi)) && (dir == 1) )
 38a:	4a39      	ldr	r2, [pc, #228]	(470 <GPIOSetDir+0x204>)
 38c:	2380      	movs	r3, #128
 38e:	021b      	lsls	r3, r3, #8
 390:	58d1      	ldr	r1, [r2, r3]
 392:	68ba      	ldr	r2, [r7, #8]
 394:	2301      	movs	r3, #1
 396:	4093      	lsls	r3, r2
 398:	400b      	ands	r3, r1
 39a:	2b00      	cmp	r3, #0
 39c:	d110      	bne.n	3c0 <GPIOSetDir+0x154>
 39e:	687b      	ldr	r3, [r7, #4]
 3a0:	2b01      	cmp	r3, #1
 3a2:	d10d      	bne.n	3c0 <GPIOSetDir+0x154>
		LPC_GPIO2->DIR |= (0x1<<bitPosi);
 3a4:	4832      	ldr	r0, [pc, #200]	(470 <GPIOSetDir+0x204>)
 3a6:	4a32      	ldr	r2, [pc, #200]	(470 <GPIOSetDir+0x204>)
 3a8:	2380      	movs	r3, #128
 3aa:	021b      	lsls	r3, r3, #8
 3ac:	58d1      	ldr	r1, [r2, r3]
 3ae:	68ba      	ldr	r2, [r7, #8]
 3b0:	2301      	movs	r3, #1
 3b2:	4093      	lsls	r3, r2
 3b4:	1c0a      	adds	r2, r1, #0
 3b6:	431a      	orrs	r2, r3
 3b8:	2380      	movs	r3, #128
 3ba:	021b      	lsls	r3, r3, #8
 3bc:	50c2      	str	r2, [r0, r3]
 3be:	e051      	b.n	464 <GPIOSetDir+0x1f8>
	  else if ( (LPC_GPIO2->DIR & (0x1<<bitPosi)) && (dir == 0) )
 3c0:	4a2b      	ldr	r2, [pc, #172]	(470 <GPIOSetDir+0x204>)
 3c2:	2380      	movs	r3, #128
 3c4:	021b      	lsls	r3, r3, #8
 3c6:	58d1      	ldr	r1, [r2, r3]
 3c8:	68ba      	ldr	r2, [r7, #8]
 3ca:	2301      	movs	r3, #1
 3cc:	4093      	lsls	r3, r2
 3ce:	400b      	ands	r3, r1
 3d0:	2b00      	cmp	r3, #0
 3d2:	d047      	beq.n	464 <GPIOSetDir+0x1f8>
 3d4:	687b      	ldr	r3, [r7, #4]
 3d6:	2b00      	cmp	r3, #0
 3d8:	d144      	bne.n	464 <GPIOSetDir+0x1f8>
		LPC_GPIO2->DIR &= ~(0x1<<bitPosi);	  
 3da:	4825      	ldr	r0, [pc, #148]	(470 <GPIOSetDir+0x204>)
 3dc:	4a24      	ldr	r2, [pc, #144]	(470 <GPIOSetDir+0x204>)
 3de:	2380      	movs	r3, #128
 3e0:	021b      	lsls	r3, r3, #8
 3e2:	58d1      	ldr	r1, [r2, r3]
 3e4:	68ba      	ldr	r2, [r7, #8]
 3e6:	2301      	movs	r3, #1
 3e8:	4093      	lsls	r3, r2
 3ea:	43db      	mvns	r3, r3
 3ec:	1c0a      	adds	r2, r1, #0
 3ee:	401a      	ands	r2, r3
 3f0:	2380      	movs	r3, #128
 3f2:	021b      	lsls	r3, r3, #8
 3f4:	50c2      	str	r2, [r0, r3]
 3f6:	e035      	b.n	464 <GPIOSetDir+0x1f8>
	break;
	case PORT3:
	  if ( !(LPC_GPIO3->DIR & (0x1<<bitPosi)) && (dir == 1) )
 3f8:	4a1e      	ldr	r2, [pc, #120]	(474 <GPIOSetDir+0x208>)
 3fa:	2380      	movs	r3, #128
 3fc:	021b      	lsls	r3, r3, #8
 3fe:	58d1      	ldr	r1, [r2, r3]
 400:	68ba      	ldr	r2, [r7, #8]
 402:	2301      	movs	r3, #1
 404:	4093      	lsls	r3, r2
 406:	400b      	ands	r3, r1
 408:	2b00      	cmp	r3, #0
 40a:	d110      	bne.n	42e <GPIOSetDir+0x1c2>
 40c:	687b      	ldr	r3, [r7, #4]
 40e:	2b01      	cmp	r3, #1
 410:	d10d      	bne.n	42e <GPIOSetDir+0x1c2>
		LPC_GPIO3->DIR |= (0x1<<bitPosi);
 412:	4818      	ldr	r0, [pc, #96]	(474 <GPIOSetDir+0x208>)
 414:	4a17      	ldr	r2, [pc, #92]	(474 <GPIOSetDir+0x208>)
 416:	2380      	movs	r3, #128
 418:	021b      	lsls	r3, r3, #8
 41a:	58d1      	ldr	r1, [r2, r3]
 41c:	68ba      	ldr	r2, [r7, #8]
 41e:	2301      	movs	r3, #1
 420:	4093      	lsls	r3, r2
 422:	1c0a      	adds	r2, r1, #0
 424:	431a      	orrs	r2, r3
 426:	2380      	movs	r3, #128
 428:	021b      	lsls	r3, r3, #8
 42a:	50c2      	str	r2, [r0, r3]
 42c:	e01a      	b.n	464 <GPIOSetDir+0x1f8>
	  else if ( (LPC_GPIO3->DIR & (0x1<<bitPosi)) && (dir == 0) )
 42e:	4a11      	ldr	r2, [pc, #68]	(474 <GPIOSetDir+0x208>)
 430:	2380      	movs	r3, #128
 432:	021b      	lsls	r3, r3, #8
 434:	58d1      	ldr	r1, [r2, r3]
 436:	68ba      	ldr	r2, [r7, #8]
 438:	2301      	movs	r3, #1
 43a:	4093      	lsls	r3, r2
 43c:	400b      	ands	r3, r1
 43e:	2b00      	cmp	r3, #0
 440:	d010      	beq.n	464 <GPIOSetDir+0x1f8>
 442:	687b      	ldr	r3, [r7, #4]
 444:	2b00      	cmp	r3, #0
 446:	d10d      	bne.n	464 <GPIOSetDir+0x1f8>
		LPC_GPIO3->DIR &= ~(0x1<<bitPosi);	  
 448:	480a      	ldr	r0, [pc, #40]	(474 <GPIOSetDir+0x208>)
 44a:	4a0a      	ldr	r2, [pc, #40]	(474 <GPIOSetDir+0x208>)
 44c:	2380      	movs	r3, #128
 44e:	021b      	lsls	r3, r3, #8
 450:	58d1      	ldr	r1, [r2, r3]
 452:	68ba      	ldr	r2, [r7, #8]
 454:	2301      	movs	r3, #1
 456:	4093      	lsls	r3, r2
 458:	43db      	mvns	r3, r3
 45a:	1c0a      	adds	r2, r1, #0
 45c:	401a      	ands	r2, r3
 45e:	2380      	movs	r3, #128
 460:	021b      	lsls	r3, r3, #8
 462:	50c2      	str	r2, [r0, r3]
	break;
	default:
	  break;
  }
  return;
}
 464:	46bd      	mov	sp, r7
 466:	b004      	add	sp, #16
 468:	bd80      	pop	{r7, pc}
 46a:	46c0      	nop			(mov r8, r8)
 46c:	50010000 	.word	0x50010000
 470:	50020000 	.word	0x50020000
 474:	50030000 	.word	0x50030000

00000478 <GPIOSetValue>:
** parameters:			port num, bit position, bit value
** Returned value:		None
** 
*****************************************************************************/
void GPIOSetValue( uint32_t portNum, uint32_t bitPosi, uint32_t bitVal )
{
 478:	b590      	push	{r4, r7, lr}
 47a:	b085      	sub	sp, #20
 47c:	af00      	add	r7, sp, #0
 47e:	60f8      	str	r0, [r7, #12]
 480:	60b9      	str	r1, [r7, #8]
 482:	607a      	str	r2, [r7, #4]
	// Check bitVal is a binary value - 0 or 1
	if (bitVal <2 )
 484:	687b      	ldr	r3, [r7, #4]
 486:	2b01      	cmp	r3, #1
 488:	d842      	bhi.n	510 <GPIOSetValue+0x98>
	 *
	 * (bitVal<<bitPosi) will be either be 0 or will contain a 1 in the
	 * appropriate bit position that matches the MASKED_ACCESS register
	 * being written to.
	 */
	  switch ( portNum )
 48a:	68fb      	ldr	r3, [r7, #12]
 48c:	603b      	str	r3, [r7, #0]
 48e:	683c      	ldr	r4, [r7, #0]
 490:	2c01      	cmp	r4, #1
 492:	d017      	beq.n	4c4 <GPIOSetValue+0x4c>
 494:	683b      	ldr	r3, [r7, #0]
 496:	2b01      	cmp	r3, #1
 498:	d306      	bcc.n	4a8 <GPIOSetValue+0x30>
 49a:	683c      	ldr	r4, [r7, #0]
 49c:	2c02      	cmp	r4, #2
 49e:	d01e      	beq.n	4de <GPIOSetValue+0x66>
 4a0:	683b      	ldr	r3, [r7, #0]
 4a2:	2b03      	cmp	r3, #3
 4a4:	d028      	beq.n	4f8 <GPIOSetValue+0x80>
 4a6:	e033      	b.n	510 <GPIOSetValue+0x98>
	  {
		case PORT0:
				 LPC_GPIO0->MASKED_ACCESS[(1<<bitPosi)] = (bitVal<<bitPosi);
 4a8:	21a0      	movs	r1, #160
 4aa:	05c9      	lsls	r1, r1, #23
 4ac:	68ba      	ldr	r2, [r7, #8]
 4ae:	2301      	movs	r3, #1
 4b0:	1c18      	adds	r0, r3, #0
 4b2:	4090      	lsls	r0, r2
 4b4:	68ba      	ldr	r2, [r7, #8]
 4b6:	687b      	ldr	r3, [r7, #4]
 4b8:	1c1c      	adds	r4, r3, #0
 4ba:	4094      	lsls	r4, r2
 4bc:	1c22      	adds	r2, r4, #0
 4be:	0083      	lsls	r3, r0, #2
 4c0:	505a      	str	r2, [r3, r1]
 4c2:	e025      	b.n	510 <GPIOSetValue+0x98>
		break;
		case PORT1:
				 LPC_GPIO1->MASKED_ACCESS[(1<<bitPosi)] = (bitVal<<bitPosi);
 4c4:	4814      	ldr	r0, [pc, #80]	(518 <GPIOSetValue+0xa0>)
 4c6:	68ba      	ldr	r2, [r7, #8]
 4c8:	2301      	movs	r3, #1
 4ca:	1c19      	adds	r1, r3, #0
 4cc:	4091      	lsls	r1, r2
 4ce:	68ba      	ldr	r2, [r7, #8]
 4d0:	687b      	ldr	r3, [r7, #4]
 4d2:	1c1c      	adds	r4, r3, #0
 4d4:	4094      	lsls	r4, r2
 4d6:	1c22      	adds	r2, r4, #0
 4d8:	008b      	lsls	r3, r1, #2
 4da:	501a      	str	r2, [r3, r0]
 4dc:	e018      	b.n	510 <GPIOSetValue+0x98>
		break;
		case PORT2:
				 LPC_GPIO2->MASKED_ACCESS[(1<<bitPosi)] = (bitVal<<bitPosi);
 4de:	480f      	ldr	r0, [pc, #60]	(51c <GPIOSetValue+0xa4>)
 4e0:	68ba      	ldr	r2, [r7, #8]
 4e2:	2301      	movs	r3, #1
 4e4:	1c19      	adds	r1, r3, #0
 4e6:	4091      	lsls	r1, r2
 4e8:	68ba      	ldr	r2, [r7, #8]
 4ea:	687b      	ldr	r3, [r7, #4]
 4ec:	1c1c      	adds	r4, r3, #0
 4ee:	4094      	lsls	r4, r2
 4f0:	1c22      	adds	r2, r4, #0
 4f2:	008b      	lsls	r3, r1, #2
 4f4:	501a      	str	r2, [r3, r0]
 4f6:	e00b      	b.n	510 <GPIOSetValue+0x98>
		break;
		case PORT3:
				 LPC_GPIO3->MASKED_ACCESS[(1<<bitPosi)] = (bitVal<<bitPosi);
 4f8:	4809      	ldr	r0, [pc, #36]	(520 <GPIOSetValue+0xa8>)
 4fa:	68ba      	ldr	r2, [r7, #8]
 4fc:	2301      	movs	r3, #1
 4fe:	1c19      	adds	r1, r3, #0
 500:	4091      	lsls	r1, r2
 502:	68ba      	ldr	r2, [r7, #8]
 504:	687b      	ldr	r3, [r7, #4]
 506:	1c1c      	adds	r4, r3, #0
 508:	4094      	lsls	r4, r2
 50a:	1c22      	adds	r2, r4, #0
 50c:	008b      	lsls	r3, r1, #2
 50e:	501a      	str	r2, [r3, r0]
		default:
		  break;
	  }
	}
  return;
}
 510:	46bd      	mov	sp, r7
 512:	b005      	add	sp, #20
 514:	bd90      	pop	{r4, r7, pc}
 516:	46c0      	nop			(mov r8, r8)
 518:	50010000 	.word	0x50010000
 51c:	50020000 	.word	0x50020000
 520:	50030000 	.word	0x50030000

00000524 <enable_timer16>:
** parameters:			timer number: 0 or 1
** Returned value:		None
** 
******************************************************************************/
void enable_timer16(uint8_t timer_num)
{
 524:	b580      	push	{r7, lr}
 526:	b082      	sub	sp, #8
 528:	af00      	add	r7, sp, #0
 52a:	1c03      	adds	r3, r0, #0
 52c:	1dfa      	adds	r2, r7, #7
 52e:	7013      	strb	r3, [r2, #0]
  if ( timer_num == 0 )
 530:	1dfb      	adds	r3, r7, #7
 532:	781b      	ldrb	r3, [r3, #0]
 534:	2b00      	cmp	r3, #0
 536:	d103      	bne.n	540 <enable_timer16+0x1c>
  {
    LPC_TMR16B0->TCR = 1;
 538:	4a04      	ldr	r2, [pc, #16]	(54c <enable_timer16+0x28>)
 53a:	2301      	movs	r3, #1
 53c:	6053      	str	r3, [r2, #4]
 53e:	e002      	b.n	546 <enable_timer16+0x22>
  }
  else
  {
    LPC_TMR16B1->TCR = 1;
 540:	4a03      	ldr	r2, [pc, #12]	(550 <enable_timer16+0x2c>)
 542:	2301      	movs	r3, #1
 544:	6053      	str	r3, [r2, #4]
  }
  return;
}
 546:	46bd      	mov	sp, r7
 548:	b002      	add	sp, #8
 54a:	bd80      	pop	{r7, pc}
 54c:	4000c000 	.word	0x4000c000
 550:	40010000 	.word	0x40010000

00000554 <init_timer16>:
** parameters:			timer number and timer interval
** Returned value:		None
** 
******************************************************************************/
void init_timer16(uint8_t timer_num, uint32_t TimerInterval) 
{
 554:	b580      	push	{r7, lr}
 556:	b082      	sub	sp, #8
 558:	af00      	add	r7, sp, #0
 55a:	1c03      	adds	r3, r0, #0
 55c:	6039      	str	r1, [r7, #0]
 55e:	1dfa      	adds	r2, r7, #7
 560:	7013      	strb	r3, [r2, #0]
  if ( timer_num == 0 )
 562:	1dfb      	adds	r3, r7, #7
 564:	781b      	ldrb	r3, [r3, #0]
 566:	2b00      	cmp	r3, #0
 568:	d13b      	bne.n	5e2 <init_timer16+0x8e>
  {
    /* Some of the I/O pins need to be clearfully planned if
    you use below module because JTAG and TIMER CAP/MAT pins are muxed. */
    LPC_SYSCON->SYSAHBCLKCTRL |= (1<<7);
 56a:	493f      	ldr	r1, [pc, #252]	(668 <init_timer16+0x114>)
 56c:	4a3e      	ldr	r2, [pc, #248]	(668 <init_timer16+0x114>)
 56e:	2380      	movs	r3, #128
 570:	58d2      	ldr	r2, [r2, r3]
 572:	2380      	movs	r3, #128
 574:	431a      	orrs	r2, r3
 576:	2380      	movs	r3, #128
 578:	50ca      	str	r2, [r1, r3]
    LPC_IOCON->PIO0_2           &= ~0x07;	/*  Timer0_16 I/O config */
 57a:	493c      	ldr	r1, [pc, #240]	(66c <init_timer16+0x118>)
 57c:	4b3b      	ldr	r3, [pc, #236]	(66c <init_timer16+0x118>)
 57e:	69da      	ldr	r2, [r3, #28]
 580:	2307      	movs	r3, #7
 582:	1c10      	adds	r0, r2, #0
 584:	4398      	bics	r0, r3
 586:	1c03      	adds	r3, r0, #0
 588:	61cb      	str	r3, [r1, #28]
    LPC_IOCON->PIO0_2           |= 0x02;		/* Timer0_16 CAP0 */
 58a:	4938      	ldr	r1, [pc, #224]	(66c <init_timer16+0x118>)
 58c:	4b37      	ldr	r3, [pc, #220]	(66c <init_timer16+0x118>)
 58e:	69da      	ldr	r2, [r3, #28]
 590:	2302      	movs	r3, #2
 592:	4313      	orrs	r3, r2
 594:	61cb      	str	r3, [r1, #28]
    LPC_IOCON->PIO0_8           &= ~0x07;	
 596:	4935      	ldr	r1, [pc, #212]	(66c <init_timer16+0x118>)
 598:	4b34      	ldr	r3, [pc, #208]	(66c <init_timer16+0x118>)
 59a:	6e1a      	ldr	r2, [r3, #96]
 59c:	2307      	movs	r3, #7
 59e:	1c10      	adds	r0, r2, #0
 5a0:	4398      	bics	r0, r3
 5a2:	1c03      	adds	r3, r0, #0
 5a4:	660b      	str	r3, [r1, #96]
    LPC_IOCON->PIO0_8           |= 0x02;		/* Timer0_16 MAT0 */
 5a6:	4931      	ldr	r1, [pc, #196]	(66c <init_timer16+0x118>)
 5a8:	4b30      	ldr	r3, [pc, #192]	(66c <init_timer16+0x118>)
 5aa:	6e1a      	ldr	r2, [r3, #96]
 5ac:	2302      	movs	r3, #2
 5ae:	4313      	orrs	r3, r2
 5b0:	660b      	str	r3, [r1, #96]
    LPC_IOCON->PIO0_9           &= ~0x07;
 5b2:	492e      	ldr	r1, [pc, #184]	(66c <init_timer16+0x118>)
 5b4:	4b2d      	ldr	r3, [pc, #180]	(66c <init_timer16+0x118>)
 5b6:	6e5a      	ldr	r2, [r3, #100]
 5b8:	2307      	movs	r3, #7
 5ba:	1c10      	adds	r0, r2, #0
 5bc:	4398      	bics	r0, r3
 5be:	1c03      	adds	r3, r0, #0
 5c0:	664b      	str	r3, [r1, #100]
    LPC_IOCON->PIO0_9           |= 0x02;		/* Timer0_16 MAT1 */
 5c2:	492a      	ldr	r1, [pc, #168]	(66c <init_timer16+0x118>)
 5c4:	4b29      	ldr	r3, [pc, #164]	(66c <init_timer16+0x118>)
 5c6:	6e5a      	ldr	r2, [r3, #100]
 5c8:	2302      	movs	r3, #2
 5ca:	4313      	orrs	r3, r2
 5cc:	664b      	str	r3, [r1, #100]

#ifdef TIMER16_GENERIC_INTS
    timer16_0_counter = 0;
#endif // TIMER16_GENERIC_INTS

    LPC_TMR16B0->MR0 = TimerInterval;
 5ce:	4a28      	ldr	r2, [pc, #160]	(670 <init_timer16+0x11c>)
 5d0:	683b      	ldr	r3, [r7, #0]
 5d2:	6193      	str	r3, [r2, #24]
//	LPC_TMR16B0->EMR &= ~(0xFF<<4);
//	LPC_TMR16B0->EMR |= ((0x3<<4)|(0x3<<6));
    LPC_TMR16B0->MCR = 3;				/* Interrupt and Reset on MR0 */
 5d4:	4a26      	ldr	r2, [pc, #152]	(670 <init_timer16+0x11c>)
 5d6:	2303      	movs	r3, #3
 5d8:	6153      	str	r3, [r2, #20]

    /* Enable the TIMER0 Interrupt */
    NVIC_EnableIRQ(TIMER_16_0_IRQn);
 5da:	2010      	movs	r0, #16
 5dc:	f000 f84c 	bl	678 <NVIC_EnableIRQ>
 5e0:	e03f      	b.n	662 <init_timer16+0x10e>
  }
  else if ( timer_num == 1 )
 5e2:	1dfb      	adds	r3, r7, #7
 5e4:	781b      	ldrb	r3, [r3, #0]
 5e6:	2b01      	cmp	r3, #1
 5e8:	d13b      	bne.n	662 <init_timer16+0x10e>
  {
    /* Some of the I/O pins need to be clearfully planned if
    you use below module because JTAG and TIMER CAP/MAT pins are muxed. */
    LPC_SYSCON->SYSAHBCLKCTRL |= (1<<8);
 5ea:	491f      	ldr	r1, [pc, #124]	(668 <init_timer16+0x114>)
 5ec:	4a1e      	ldr	r2, [pc, #120]	(668 <init_timer16+0x114>)
 5ee:	2380      	movs	r3, #128
 5f0:	58d2      	ldr	r2, [r2, r3]
 5f2:	2380      	movs	r3, #128
 5f4:	005b      	lsls	r3, r3, #1
 5f6:	431a      	orrs	r2, r3
 5f8:	2380      	movs	r3, #128
 5fa:	50ca      	str	r2, [r1, r3]
    LPC_IOCON->PIO1_8           &= ~0x07;	/*  Timer1_16 I/O config */
 5fc:	491b      	ldr	r1, [pc, #108]	(66c <init_timer16+0x118>)
 5fe:	4b1b      	ldr	r3, [pc, #108]	(66c <init_timer16+0x118>)
 600:	695a      	ldr	r2, [r3, #20]
 602:	2307      	movs	r3, #7
 604:	1c10      	adds	r0, r2, #0
 606:	4398      	bics	r0, r3
 608:	1c03      	adds	r3, r0, #0
 60a:	614b      	str	r3, [r1, #20]
    LPC_IOCON->PIO1_8           |= 0x01;		/* Timer1_16 CAP0 */
 60c:	4917      	ldr	r1, [pc, #92]	(66c <init_timer16+0x118>)
 60e:	4b17      	ldr	r3, [pc, #92]	(66c <init_timer16+0x118>)
 610:	695a      	ldr	r2, [r3, #20]
 612:	2301      	movs	r3, #1
 614:	4313      	orrs	r3, r2
 616:	614b      	str	r3, [r1, #20]
    LPC_IOCON->PIO1_9           &= ~0x07;	
 618:	4914      	ldr	r1, [pc, #80]	(66c <init_timer16+0x118>)
 61a:	4b14      	ldr	r3, [pc, #80]	(66c <init_timer16+0x118>)
 61c:	6b9a      	ldr	r2, [r3, #56]
 61e:	2307      	movs	r3, #7
 620:	1c10      	adds	r0, r2, #0
 622:	4398      	bics	r0, r3
 624:	1c03      	adds	r3, r0, #0
 626:	638b      	str	r3, [r1, #56]
    LPC_IOCON->PIO1_9           |= 0x01;		/* Timer1_16 MAT0 */
 628:	4910      	ldr	r1, [pc, #64]	(66c <init_timer16+0x118>)
 62a:	4b10      	ldr	r3, [pc, #64]	(66c <init_timer16+0x118>)
 62c:	6b9a      	ldr	r2, [r3, #56]
 62e:	2301      	movs	r3, #1
 630:	4313      	orrs	r3, r2
 632:	638b      	str	r3, [r1, #56]
    LPC_IOCON->PIO1_10          &= ~0x07;
 634:	490d      	ldr	r1, [pc, #52]	(66c <init_timer16+0x118>)
 636:	4b0d      	ldr	r3, [pc, #52]	(66c <init_timer16+0x118>)
 638:	6eda      	ldr	r2, [r3, #108]
 63a:	2307      	movs	r3, #7
 63c:	1c10      	adds	r0, r2, #0
 63e:	4398      	bics	r0, r3
 640:	1c03      	adds	r3, r0, #0
 642:	66cb      	str	r3, [r1, #108]
    LPC_IOCON->PIO1_10          |= 0x02;		/* Timer1_16 MAT1 */	
 644:	4909      	ldr	r1, [pc, #36]	(66c <init_timer16+0x118>)
 646:	4b09      	ldr	r3, [pc, #36]	(66c <init_timer16+0x118>)
 648:	6eda      	ldr	r2, [r3, #108]
 64a:	2302      	movs	r3, #2
 64c:	4313      	orrs	r3, r2
 64e:	66cb      	str	r3, [r1, #108]

#ifdef TIMER16_GENERIC_INTS
    timer16_1_counter = 0;
#endif // TIMER16_GENERIC_INTS
    LPC_TMR16B1->MR0 = TimerInterval;
 650:	4a08      	ldr	r2, [pc, #32]	(674 <init_timer16+0x120>)
 652:	683b      	ldr	r3, [r7, #0]
 654:	6193      	str	r3, [r2, #24]
//	LPC_TMR16B1->EMR &= ~(0xFF<<4);
//	LPC_TMR16B1->EMR |= ((0x3<<4)|(0x3<<6));
    LPC_TMR16B1->MCR = 3;				/* Interrupt and Reset on MR1 */
 656:	4a07      	ldr	r2, [pc, #28]	(674 <init_timer16+0x120>)
 658:	2303      	movs	r3, #3
 65a:	6153      	str	r3, [r2, #20]

    /* Enable the TIMER1 Interrupt */
    NVIC_EnableIRQ(TIMER_16_1_IRQn);
 65c:	2011      	movs	r0, #17
 65e:	f000 f80b 	bl	678 <NVIC_EnableIRQ>
  }
  return;
}
 662:	46bd      	mov	sp, r7
 664:	b002      	add	sp, #8
 666:	bd80      	pop	{r7, pc}
 668:	40048000 	.word	0x40048000
 66c:	40044000 	.word	0x40044000
 670:	4000c000 	.word	0x4000c000
 674:	40010000 	.word	0x40010000

00000678 <NVIC_EnableIRQ>:
 *
 * Enable a device specific interupt in the NVIC interrupt controller.
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
 678:	b580      	push	{r7, lr}
 67a:	b082      	sub	sp, #8
 67c:	af00      	add	r7, sp, #0
 67e:	1c03      	adds	r3, r0, #0
 680:	1dfa      	adds	r2, r7, #7
 682:	7013      	strb	r3, [r2, #0]
  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
 684:	4905      	ldr	r1, [pc, #20]	(69c <NVIC_EnableIRQ+0x24>)
 686:	1dfb      	adds	r3, r7, #7
 688:	781b      	ldrb	r3, [r3, #0]
 68a:	1c1a      	adds	r2, r3, #0
 68c:	231f      	movs	r3, #31
 68e:	401a      	ands	r2, r3
 690:	2301      	movs	r3, #1
 692:	4093      	lsls	r3, r2
 694:	600b      	str	r3, [r1, #0]
}
 696:	46bd      	mov	sp, r7
 698:	b002      	add	sp, #8
 69a:	bd80      	pop	{r7, pc}
 69c:	e000e100 	.word	0xe000e100

000006a0 <TIMER16_0_IRQHandler>:
** parameters:			None
** Returned value:		None
**
******************************************************************************/
void TIMER16_0_IRQHandler(void)
{
 6a0:	b580      	push	{r7, lr}
 6a2:	af00      	add	r7, sp, #0
  LPC_TMR16B0->IR = 1;			/* clear interrupt flag */
 6a4:	4a04      	ldr	r2, [pc, #16]	(6b8 <TIMER16_0_IRQHandler+0x18>)
 6a6:	2301      	movs	r3, #1
 6a8:	6013      	str	r3, [r2, #0]
  timer16_0_counter++;
 6aa:	4b04      	ldr	r3, [pc, #16]	(6bc <TIMER16_0_IRQHandler+0x1c>)
 6ac:	681b      	ldr	r3, [r3, #0]
 6ae:	1c5a      	adds	r2, r3, #1
 6b0:	4b02      	ldr	r3, [pc, #8]	(6bc <TIMER16_0_IRQHandler+0x1c>)
 6b2:	601a      	str	r2, [r3, #0]
  return;
}
 6b4:	46bd      	mov	sp, r7
 6b6:	bd80      	pop	{r7, pc}
 6b8:	4000c000 	.word	0x4000c000
 6bc:	10000004 	.word	0x10000004

000006c0 <TIMER16_1_IRQHandler>:
** parameters:			None
** Returned value:		None
**
******************************************************************************/
void TIMER16_1_IRQHandler(void)
{
 6c0:	b580      	push	{r7, lr}
 6c2:	af00      	add	r7, sp, #0
  LPC_TMR16B1->IR = 1;			/* clear interrupt flag */
 6c4:	4a04      	ldr	r2, [pc, #16]	(6d8 <TIMER16_1_IRQHandler+0x18>)
 6c6:	2301      	movs	r3, #1
 6c8:	6013      	str	r3, [r2, #0]
  timer16_1_counter++;
 6ca:	4b04      	ldr	r3, [pc, #16]	(6dc <TIMER16_1_IRQHandler+0x1c>)
 6cc:	681b      	ldr	r3, [r3, #0]
 6ce:	1c5a      	adds	r2, r3, #1
 6d0:	4b02      	ldr	r3, [pc, #8]	(6dc <TIMER16_1_IRQHandler+0x1c>)
 6d2:	601a      	str	r2, [r3, #0]
  return;
}
 6d4:	46bd      	mov	sp, r7
 6d6:	bd80      	pop	{r7, pc}
 6d8:	40010000 	.word	0x40010000
 6dc:	10000008 	.word	0x10000008

000006e0 <SystemInit>:
 *
 * @brief  Setup the microcontroller system.
 *         Initialize the System.
 */
void SystemInit (void)
{
 6e0:	b580      	push	{r7, lr}
 6e2:	b082      	sub	sp, #8
 6e4:	af00      	add	r7, sp, #0
#if (CLOCK_SETUP)                                 /* Clock Setup              */
#if (SYSCLK_SETUP)                                /* System Clock Setup       */
#if (SYSOSC_SETUP)                                /* System Oscillator Setup  */
  uint32_t i;

  LPC_SYSCON->PDRUNCFG     &= ~(1 << 5);          /* Power-up System Osc      */
 6e6:	4934      	ldr	r1, [pc, #208]	(7b8 <SystemInit+0xd8>)
 6e8:	4a33      	ldr	r2, [pc, #204]	(7b8 <SystemInit+0xd8>)
 6ea:	238e      	movs	r3, #142
 6ec:	009b      	lsls	r3, r3, #2
 6ee:	58d2      	ldr	r2, [r2, r3]
 6f0:	2320      	movs	r3, #32
 6f2:	439a      	bics	r2, r3
 6f4:	238e      	movs	r3, #142
 6f6:	009b      	lsls	r3, r3, #2
 6f8:	50ca      	str	r2, [r1, r3]
  LPC_SYSCON->SYSOSCCTRL    = SYSOSCCTRL_Val;
 6fa:	4a2f      	ldr	r2, [pc, #188]	(7b8 <SystemInit+0xd8>)
 6fc:	2300      	movs	r3, #0
 6fe:	6213      	str	r3, [r2, #32]
  for (i = 0; i < 200; i++) __NOP();
 700:	2300      	movs	r3, #0
 702:	607b      	str	r3, [r7, #4]
 704:	e004      	b.n	710 <SystemInit+0x30>
 706:	f000 f85b 	bl	7c0 <__NOP>
 70a:	687b      	ldr	r3, [r7, #4]
 70c:	3301      	adds	r3, #1
 70e:	607b      	str	r3, [r7, #4]
 710:	687b      	ldr	r3, [r7, #4]
 712:	2bc7      	cmp	r3, #199
 714:	d9f7      	bls.n	706 <SystemInit+0x26>
  LPC_SYSCON->SYSPLLCLKSEL  = SYSPLLCLKSEL_Val;   /* Select PLL Input         */
 716:	4a28      	ldr	r2, [pc, #160]	(7b8 <SystemInit+0xd8>)
 718:	2301      	movs	r3, #1
 71a:	6413      	str	r3, [r2, #64]
  LPC_SYSCON->SYSPLLCLKUEN  = 0x01;               /* Update Clock Source      */
 71c:	4a26      	ldr	r2, [pc, #152]	(7b8 <SystemInit+0xd8>)
 71e:	2301      	movs	r3, #1
 720:	6453      	str	r3, [r2, #68]
  LPC_SYSCON->SYSPLLCLKUEN  = 0x00;               /* Toggle Update Register   */
 722:	4a25      	ldr	r2, [pc, #148]	(7b8 <SystemInit+0xd8>)
 724:	2300      	movs	r3, #0
 726:	6453      	str	r3, [r2, #68]
  LPC_SYSCON->SYSPLLCLKUEN  = 0x01;
 728:	4a23      	ldr	r2, [pc, #140]	(7b8 <SystemInit+0xd8>)
 72a:	2301      	movs	r3, #1
 72c:	6453      	str	r3, [r2, #68]
  while (!(LPC_SYSCON->SYSPLLCLKUEN & 0x01));     /* Wait Until Updated       */
 72e:	4b22      	ldr	r3, [pc, #136]	(7b8 <SystemInit+0xd8>)
 730:	6c5b      	ldr	r3, [r3, #68]
 732:	1c1a      	adds	r2, r3, #0
 734:	2301      	movs	r3, #1
 736:	4013      	ands	r3, r2
 738:	2b00      	cmp	r3, #0
 73a:	d0f8      	beq.n	72e <SystemInit+0x4e>
#if (SYSPLL_SETUP)                                /* System PLL Setup         */
  LPC_SYSCON->SYSPLLCTRL    = SYSPLLCTRL_Val;
 73c:	4a1e      	ldr	r2, [pc, #120]	(7b8 <SystemInit+0xd8>)
 73e:	2323      	movs	r3, #35
 740:	6093      	str	r3, [r2, #8]
  LPC_SYSCON->PDRUNCFG     &= ~(1 << 7);          /* Power-up SYSPLL          */
 742:	491d      	ldr	r1, [pc, #116]	(7b8 <SystemInit+0xd8>)
 744:	4a1c      	ldr	r2, [pc, #112]	(7b8 <SystemInit+0xd8>)
 746:	238e      	movs	r3, #142
 748:	009b      	lsls	r3, r3, #2
 74a:	58d2      	ldr	r2, [r2, r3]
 74c:	2380      	movs	r3, #128
 74e:	439a      	bics	r2, r3
 750:	238e      	movs	r3, #142
 752:	009b      	lsls	r3, r3, #2
 754:	50ca      	str	r2, [r1, r3]
  while (!(LPC_SYSCON->SYSPLLSTAT & 0x01));	      /* Wait Until PLL Locked    */
 756:	4b18      	ldr	r3, [pc, #96]	(7b8 <SystemInit+0xd8>)
 758:	68db      	ldr	r3, [r3, #12]
 75a:	1c1a      	adds	r2, r3, #0
 75c:	2301      	movs	r3, #1
 75e:	4013      	ands	r3, r2
 760:	2b00      	cmp	r3, #0
 762:	d0f8      	beq.n	756 <SystemInit+0x76>
#endif
#if (WDTOSC_SETUP)                                /* Watchdog Oscillator Setup*/
  LPC_SYSCON->WDTOSCCTRL    = WDTOSCCTRL_Val;
  LPC_SYSCON->PDRUNCFG     &= ~(1 << 6);          /* Power-up WDT Clock       */
#endif
  LPC_SYSCON->MAINCLKSEL    = MAINCLKSEL_Val;     /* Select PLL Clock Output  */
 764:	4a14      	ldr	r2, [pc, #80]	(7b8 <SystemInit+0xd8>)
 766:	2303      	movs	r3, #3
 768:	6713      	str	r3, [r2, #112]
  LPC_SYSCON->MAINCLKUEN    = 0x01;               /* Update MCLK Clock Source */
 76a:	4a13      	ldr	r2, [pc, #76]	(7b8 <SystemInit+0xd8>)
 76c:	2301      	movs	r3, #1
 76e:	6753      	str	r3, [r2, #116]
  LPC_SYSCON->MAINCLKUEN    = 0x00;               /* Toggle Update Register   */
 770:	4a11      	ldr	r2, [pc, #68]	(7b8 <SystemInit+0xd8>)
 772:	2300      	movs	r3, #0
 774:	6753      	str	r3, [r2, #116]
  LPC_SYSCON->MAINCLKUEN    = 0x01;
 776:	4a10      	ldr	r2, [pc, #64]	(7b8 <SystemInit+0xd8>)
 778:	2301      	movs	r3, #1
 77a:	6753      	str	r3, [r2, #116]
  while (!(LPC_SYSCON->MAINCLKUEN & 0x01));       /* Wait Until Updated       */
 77c:	4b0e      	ldr	r3, [pc, #56]	(7b8 <SystemInit+0xd8>)
 77e:	6f5b      	ldr	r3, [r3, #116]
 780:	1c1a      	adds	r2, r3, #0
 782:	2301      	movs	r3, #1
 784:	4013      	ands	r3, r2
 786:	2b00      	cmp	r3, #0
 788:	d0f8      	beq.n	77c <SystemInit+0x9c>
#endif

  LPC_SYSCON->SYSAHBCLKDIV  = SYSAHBCLKDIV_Val;
 78a:	4a0b      	ldr	r2, [pc, #44]	(7b8 <SystemInit+0xd8>)
 78c:	2301      	movs	r3, #1
 78e:	6793      	str	r3, [r2, #120]
  LPC_SYSCON->SYSAHBCLKCTRL = AHBCLKCTRL_Val;
 790:	4909      	ldr	r1, [pc, #36]	(7b8 <SystemInit+0xd8>)
 792:	2280      	movs	r2, #128
 794:	4b09      	ldr	r3, [pc, #36]	(7bc <SystemInit+0xdc>)
 796:	508b      	str	r3, [r1, r2]
  LPC_SYSCON->SSP0CLKDIV    = SSP0CLKDIV_Val;
 798:	4907      	ldr	r1, [pc, #28]	(7b8 <SystemInit+0xd8>)
 79a:	2294      	movs	r2, #148
 79c:	2301      	movs	r3, #1
 79e:	508b      	str	r3, [r1, r2]
  LPC_SYSCON->UARTCLKDIV    = UARTCLKDIV_Val;
 7a0:	4905      	ldr	r1, [pc, #20]	(7b8 <SystemInit+0xd8>)
 7a2:	2298      	movs	r2, #152
 7a4:	2301      	movs	r3, #1
 7a6:	508b      	str	r3, [r1, r2]
  LPC_SYSCON->SSP1CLKDIV    = SSP1CLKDIV_Val;
 7a8:	4903      	ldr	r1, [pc, #12]	(7b8 <SystemInit+0xd8>)
 7aa:	229c      	movs	r2, #156
 7ac:	2301      	movs	r3, #1
 7ae:	508b      	str	r3, [r1, r2]


#if (MEMMAP_SETUP || MEMMAP_INIT)       /* Memory Mapping Setup               */
  LPC_SYSCON->SYSMEMREMAP = SYSMEMREMAP_Val;
#endif
}
 7b0:	46bd      	mov	sp, r7
 7b2:	b002      	add	sp, #8
 7b4:	bd80      	pop	{r7, pc}
 7b6:	46c0      	nop			(mov r8, r8)
 7b8:	40048000 	.word	0x40048000
 7bc:	0001005f 	.word	0x0001005f

000007c0 <__NOP>:
static __INLINE void __disable_irq()              { __ASM volatile ("cpsid i"); }

static __INLINE void __enable_fault_irq()         { __ASM volatile ("cpsie f"); }
static __INLINE void __disable_fault_irq()        { __ASM volatile ("cpsid f"); }

static __INLINE void __NOP()                      { __ASM volatile ("nop"); }
 7c0:	b580      	push	{r7, lr}
 7c2:	af00      	add	r7, sp, #0
 7c4:	46c0      	nop			(mov r8, r8)
 7c6:	46bd      	mov	sp, r7
 7c8:	bd80      	pop	{r7, pc}
 7ca:	46c0      	nop			(mov r8, r8)

000007cc <__aeabi_idiv0>:
 7cc:	4770      	bx	lr
 7ce:	46c0      	nop			(mov r8, r8)

000007d0 <__aeabi_uidiv>:
 7d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 7d2:	2900      	cmp	r1, #0
 7d4:	d02e      	beq.n	834 <__aeabi_uidiv+0x64>
 7d6:	0903      	lsrs	r3, r0, #4
 7d8:	4299      	cmp	r1, r3
 7da:	d830      	bhi.n	83e <__aeabi_uidiv+0x6e>
 7dc:	2401      	movs	r4, #1
 7de:	0109      	lsls	r1, r1, #4
 7e0:	3401      	adds	r4, #1
 7e2:	4299      	cmp	r1, r3
 7e4:	d9fb      	bls.n	7de <__aeabi_uidiv+0xe>
 7e6:	2308      	movs	r3, #8
 7e8:	2200      	movs	r2, #0
 7ea:	469c      	mov	ip, r3
 7ec:	2704      	movs	r7, #4
 7ee:	2602      	movs	r6, #2
 7f0:	2501      	movs	r5, #1
 7f2:	e000      	b.n	7f6 <__aeabi_uidiv+0x26>
 7f4:	0909      	lsrs	r1, r1, #4
 7f6:	08c3      	lsrs	r3, r0, #3
 7f8:	0112      	lsls	r2, r2, #4
 7fa:	428b      	cmp	r3, r1
 7fc:	d303      	bcc.n	806 <__aeabi_uidiv+0x36>
 7fe:	00cb      	lsls	r3, r1, #3
 800:	1ac0      	subs	r0, r0, r3
 802:	4663      	mov	r3, ip
 804:	431a      	orrs	r2, r3
 806:	0883      	lsrs	r3, r0, #2
 808:	4299      	cmp	r1, r3
 80a:	d802      	bhi.n	812 <__aeabi_uidiv+0x42>
 80c:	008b      	lsls	r3, r1, #2
 80e:	1ac0      	subs	r0, r0, r3
 810:	433a      	orrs	r2, r7
 812:	0843      	lsrs	r3, r0, #1
 814:	4299      	cmp	r1, r3
 816:	d802      	bhi.n	81e <__aeabi_uidiv+0x4e>
 818:	004b      	lsls	r3, r1, #1
 81a:	1ac0      	subs	r0, r0, r3
 81c:	4332      	orrs	r2, r6
 81e:	4281      	cmp	r1, r0
 820:	d801      	bhi.n	826 <__aeabi_uidiv+0x56>
 822:	1a40      	subs	r0, r0, r1
 824:	432a      	orrs	r2, r5
 826:	3c01      	subs	r4, #1
 828:	2c00      	cmp	r4, #0
 82a:	d1e3      	bne.n	7f4 <__aeabi_uidiv+0x24>
 82c:	1c10      	adds	r0, r2, #0
 82e:	bcf8      	pop	{r3, r4, r5, r6, r7}
 830:	bc02      	pop	{r1}
 832:	4708      	bx	r1
 834:	2000      	movs	r0, #0
 836:	f7ff ffc9 	bl	7cc <__aeabi_idiv0>
 83a:	1c02      	adds	r2, r0, #0
 83c:	e7f6      	b.n	82c <__aeabi_uidiv+0x5c>
 83e:	2401      	movs	r4, #1
 840:	e7d1      	b.n	7e6 <__aeabi_uidiv+0x16>
 842:	46c0      	nop			(mov r8, r8)
